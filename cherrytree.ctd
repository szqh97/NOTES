<?xml version="1.0" ?><cherrytree><node name="C++" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="1"><rich_text>1.
        u.lmsg.content =
            (content_t*) malloc (sizeof (content_t) + size_);
        if (!u.lmsg.content) {
            errno = ENOMEM;
            return -1;
        }
if the lmsg.content memory malloc failed, set errno to ENONMEM
2.</rich_text><rich_text foreground="#ff0000">placement new</rich_text><rich_text>in zeromq in content_t::refcnt
msg.hpp 103
3. gcc 编译器从4.3以后不用 -lpthread, 使用-pthread代替
4.C++快速读文件
</rich_text><rich_text link="webs https://www.byvoid.com/blog/fast-readfile">https://www.byvoid.com/blog/fast-readfile</rich_text><rich_text>


5.模板函数的声明与定义分离会编译失败


第三种办法 最简单的使用swap,清除元素并回收内存

1.     vector &lt;int&gt;().swap(vecInt);  //清除容器并最小化它的容量，

2. 


3.     j= vecInt.capacity();       //j=0  

4.     i = vecInt.size();          //i=0       


该语句是由vector &lt;int&gt;(vecInt).swap(vecInt)的变体而来，一下解释引自csdn：

std::vector&lt;T&gt;(v).swap(v);的作用相当于：    
  {  
  std::vector&lt;T&gt;   temp(v);//1  
  temp.swap(v);//2  
  }  
  第一句产生一个和v内容一模一样的vector，只不过temp的容量是恰好满足其大小的  
  第二句把v和temp交换  
  然后temp就自动解析掉了  
    
  这样写的作用是：把v的容量缩小到最佳值

该例中执行这句时，capacity收缩到500
</rich_text><node name="tips" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="5"><rich_text>1.
        u.lmsg.content =
            (content_t*) malloc (sizeof (content_t) + size_);
        if (!u.lmsg.content) {
            errno = ENOMEM;
            return -1;
        }
if the lmsg.content memory malloc failed, set errno to ENONMEM
2.</rich_text><rich_text foreground="#ff0000">placement new</rich_text><rich_text>in zeromq in content_t::refcnt
msg.hpp 103
3. gcc 编译器从4.3以后不用 -lpthread, 使用-pthread代替
4.C++快速读文件
</rich_text><rich_text link="webs https://www.byvoid.com/blog/fast-readfile">https://www.byvoid.com/blog/fast-readfile</rich_text><rich_text>


5.模板函数的声明与定义分离会编译失败


第三种办法 最简单的使用swap,清除元素并回收内存

1.     vector &lt;int&gt;().swap(vecInt);  //清除容器并最小化它的容量，

2. 


3.     j= vecInt.capacity();       //j=0  

4.     i = vecInt.size();          //i=0       


该语句是由vector &lt;int&gt;(vecInt).swap(vecInt)的变体而来，一下解释引自csdn：

std::vector&lt;T&gt;(v).swap(v);的作用相当于：    
  {  
  std::vector&lt;T&gt;   temp(v);//1  
  temp.swap(v);//2  
  }  
  第一句产生一个和v内容一模一样的vector，只不过temp的容量是恰好满足其大小的  
  第二句把v和temp交换  
  然后temp就自动解析掉了  
    
  这样写的作用是：把v的容量缩小到最佳值

该例中执行这句时，capacity收缩到500
LD_PRELOAD环境变量加载一些库,覆盖原有的方法,</rich_text></node><node name="FAQ" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="6"><rich_text>how to use </rich_text><rich_text foreground="#ff0000">delete this</rich_text><rich_text>
As long as you're careful, it's OK for an object to commit suicide (delete this).
Here's how I define &quot;careful&quot;:
1. You must be absolutely 100% positively sure that this object was allocated via new (not by new[], nor by </rich_text><rich_text link="webs http://www.parashift.com/c++-faq-lite/placement-new.html">placementnew</rich_text><rich_text>, nor a local object on the stack, nor a global, nor a member of another object; but by plain ordinary new).

2. You must be absolutely 100% positively sure that your member function will be the last member function invoked on this object.

3. You must be absolutely 100% positively sure that the rest of your member function (after the delete this line) doesn't touch any piece ofthis object (including calling any other member functions or touching any data members).

4. You must be absolutely 100% positively sure that no one even touches the this pointer itself after the delete this line.  In other words, you must not examine it, compare it with another pointer, compare it with NULL, print it, cast it, do anything with it.

Naturally the usual caveats apply in cases where your this pointer is a pointer to a base class when you don't have a </rich_text><rich_text link="webs http://www.parashift.com/c++-faq-lite/virtual-dtors.html">virtual destructor</rich_text><rich_text>.             


正确释放vector的内存

</rich_text><rich_text link="webs http://blog.jobbole.com/37700/">http://blog.jobbole.com/37700/</rich_text><rich_text>
vector&lt;type&gt;(v).swap(v);

当然，上面这种方法虽然释放了内存，但是同时也增加了拷贝数据的时间消耗。 不过一般需要重新调整容量的情况都是 vector本身元素较少的情况，所以 时间消耗可以忽略不计。
因此建议以后大家都将调用 clear() 改为 swap() 吧。
之所以大多数程序的“入口”是 main，是因为连接器缺省会连接一个叫 crt0.o 或 者 crt0.lib 之类的库，这个库才是一个程序真正的入口，这个真正的入口作了一段初始化之后将控制权交给 main。大多数情况下用户程序不会自 己初始化这些东西，所以缺省连接这个库。

如果你自己完成这部分初始化，完全可以抛弃 main。

main 不是程序的入口，只不过是一个普通的符号而已。


gcc -g -nostartfiles -e myentry myentry.c 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int myentry(int argc, char *argv[])
{
    printf(&quot;Start from myentry\n&quot;);
    //return 0;
    exit(0);
}

LD_PRELOAD环境变量加载一些库,覆盖原有的方法,
</rich_text></node><node name="todo" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="7"><rich_text foreground="#000000">1. Loki 封装设计模式的一个类库，有时间看一下</rich_text><rich_text>
</rich_text><rich_text link="webs http://loki-lib.sourceforge.net/index.php?n=Main.HomePage">http://loki-lib.sourceforge.net/index.php?n=Main.HomePage</rich_text><rich_text>
Documentation
</rich_text><rich_text link="webs http://loki-lib.sourceforge.net/html/modules.html">http://loki-lib.sourceforge.net/html/modules.html</rich_text><rich_text>
2. zmq里有一个mutex_t的类,封装了pthread_mutex_xxx的操作
3. Linux poll&amp;Epoll </rich_text><rich_text link="webs http://bbs.chinaunix.net/it/linuxpoll.shtml">http://bbs.chinaunix.net/it/linuxpoll.shtml</rich_text><rich_text>
ioctl, select, poll, epolll这些的用法 
4. YUV转avi
</rich_text><rich_text link="webs http://lihaoyan.blog.sohu.com/146539049.html">http://lihaoyan.blog.sohu.com/146539049.html</rich_text><rich_text>
5.shell
</rich_text><rich_text link="webs http://coolshell.cn/articles/9410.html">http://coolshell.cn/articles/9410.html</rich_text><rich_text>


6. C++数组不支持多态?
</rich_text><rich_text link="webs http://coolshell.cn/articles/9543.html">http://coolshell.cn/articles/9543.html</rich_text><rich_text>


7. C++的坑真的多吗?
</rich_text><rich_text link="webs http://coolshell.cn/articles/7992.html">http://coolshell.cn/articles/7992.html</rich_text><rich_text>
8.微博中有关尾递归和非尾递归的讨论q
9. q
10. 


9. C++ 语言的15个隐晦特性
</rich_text><rich_text link="webs http://blog.jobbole.com/54140/">http://blog.jobbole.com/54140/</rich_text><rich_text>
10 刘未鹏 C++
</rich_text><rich_text link="webs http://blog.csdn.net/pongba/article/details/90643">http://blog.csdn.net/pongba/article/details/90643</rich_text><rich_text>

C++ Policy 
</rich_text><rich_text link="webs http://blog.csdn.net/happylife1527/article/details/8204734">http://blog.csdn.net/happylife1527/article/details/8204734</rich_text><rich_text>

C++ design pattern &amp; others
</rich_text><rich_text link="webs http://sourcemaking.com/design_patterns">http://sourcemaking.com/design_patterns</rich_text><rich_text>

C++设计模式
</rich_text><rich_text link="webs http://c.chinaitlab.com/special/sjms/Index.html">http://c.chinaitlab.com/special/sjms/Index.html</rich_text></node><node name="others" prog_lang="custom-colors" readonly="False" tags="others" unique_id="28"><rich_text weight="heavy">VOA</rich_text><rich_text>
</rich_text><rich_text style="italic">voa     mms://a1905.l211052072.c2110.g.lm.akamaistream.net/D/1905/2110/v0001/reflector:52072</rich_text><rich_text>

voa news mms://a823.l211056822.c2110.g.lm.akamaistream.net/d/823/2110/v0001/reflector:56822</rich_text></node><node name="vobile 常用" prog_lang="custom-colors" readonly="False" tags="vobile" unique_id="29"><rich_text>TVADS 发送job
</rich_text><rich_text justification="left"></rich_text><codebox char_offset="12" frame_height="80" frame_width="100" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="sh" width_in_pixels="False">curl -d '@task' &quot;http://192.168.1.50:8080/jobTracker/task/submit&quot; -H&quot;Content-Type:application/json&quot;</codebox></node><node name="snippet" prog_lang="custom-colors" readonly="False" tags="" unique_id="42"><rich_text justification="left"></rich_text><rich_text>
</rich_text><rich_text justification="left"></rich_text><codebox char_offset="0" frame_height="500" frame_width="100" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="cpp" width_in_pixels="False">/*异常处理，通过流来计算行数 */
void readIntegerFile(const string&amp; fileName, vector&lt;int&gt;&amp; dest) throw(FileOpenError, FileReadError)
{
	ifstream istr;
	int temp;
	string line;
	int lineNumber = 0;
	istr.open(fileName.c_str());
	if (istr.fail()) 	
	{
		// We failed to open the file: throw an exception.
		throw FileOpenError(fileName);
	}
	while (!istr.eof()) 
	{
		// Read one line from the file.
		getline(istr, line);
		lineNumber++;
		// Create a string stream out of the line.
		istringstream lineStream(line);
		// Read the integers one by one and add them to the vector.
		while (lineStream &gt;&gt; temp) 
		{
			dest.push_back(temp);
		}
		if (!lineStream.eof()) 
		{
			// Some other error. Close the file and throw an exception.
			istr.close();
			throw FileReadError(fileName, lineNumber);
		}
	}
	istr.close();
}</codebox><codebox char_offset="2" frame_height="500" frame_width="100" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="cpp" width_in_pixels="False"></codebox></node><node name="Modern C++ " prog_lang="cpp" readonly="False" tags="" unique_id="50"><rich_text>//////////////////////////////////////////////////
    基于Policy的Class设计 （Policy-Based Class Design）

Q1. 什么是Policy， policy 与纯虚函数有什么异同 什么是符合 policy 的一个类？P9
Q2. 何为 template template 参数？
    host class ：如果class使用一个或者多个policies 称其为host class， 它负责把policy
    的结构和行为组合为一个更复杂的结构和行为。每一个参数代表一个policy
// Library code
template &lt;class CreationPolicy&gt;
class widgetManager: public CreationPolicy
{ ... };

//Aplication code
typedef WidgetCreator&lt; OpNewCreator&lt;Widget&gt; &gt; myWidgetMgr;

一般来说，host class 已经知道policy class所需的参数， 或是轻易可推导出来。
// Library code
template &lt;template &lt;class Created&gt; class CreationPolicy = OpNewCreator&gt;
class widgeManager : public CreationPolicy&lt;Widge&gt;
{ ... };

// Aplication code
typedef WidgetManager&lt;OpNewCreator&gt; MyWidgetMgr;

Policy 不适用于动态连结和二进位接口（何为二进位接口？），所以本质上Policies和传统的接口并不互相竞争

关于析构的问题：可以将一个host class自动转换为一个Policy class(向上转型）
并稍后delete 该指针，否则直接delete该指针会出现不可预知的行为;在Policy中定义虚析构函数，
    会妨碍Policy的静态连结特性，会为对象大小带来额外的开销。Policy只规范行为，
    要避免虚析构函数

Q： 虚函数是不是在执行速度上有额外的开销？

将class 分解为polices时的准则：
1. 把你的class内的”设计决定”局部化、命令，分离出来。
2. 找出正交的policies--也就是彼此之间没有交互作用、可独立更动的polices
Q: 在设计一个类时，如何拆分出正交的Policies？
如果必须使用和非正交的Policies，尽可能借着 ” 把policy class 当做引用参数传给其他policy class template function “ 来降低相依性，这样policy就必须暴露一些实现细节给其他 的Policy 会降低封装性
Policy机制由template 和多重继承组成   
Policy-to-Policy 的拷贝方式

/////////////////////////////////////////////
不存在template函数的特化.

偏特化机制不能用在函数上，不论成员函数还是非成员函数。
1. 可以全特化 class template 中的成员函数，但是不能偏特化它们
2. 不能偏特化namespace-level 函数，（函数重载） 

/////////////////////////////////////////////
local class 不能定义static成员变量，也不能访问non-static局部变量。可以在template 函数中使用。定义template 函数内的local class 可以使用函数的template参数
任何运用template class的手法，都可以改用&quot;函数外的template class&quot;来完成。
local class 类似于Java中的final， 外界不能继承一个隐藏于函数内的local class。如果没有local class 要实现java中的final，需要在编译元中加上一个无具名的命名空间。
//////////////////////////////////////////
   Mapping Integral Constants to types
   适用Int2Type的两个条件：
   1. 有必要根据某个编译期常数调用一个或数个不同的函数
   2. 有必要在编译期实施&quot;分派&quot;
   如果在执行是进行分派，只要使用if-else or switch 就好了
   //////////////////////////
       编译期间的侦测可转换性和继承性
可以把sizeof用在任何表达式，不论后者有多复杂，sizeof会直接传回大小，不会等到执行时。这意味着sizeof可以感知重载，模板实例化，转换规则，或任何发生在C++表达式上的机制
//////////////////////
C++不允许reference to reference
虚函数没有template 版本
在编译时不能使用迭代，只能用递归，原因：
Template 更明确的是template specialization ,提供编译期间的if叙述
在编译期间数值是不可变的，一旦定义了一个整数常数，就不能再改变它
在编译期间没有一个可变化的东西，在编译期间没法使用迭代，只可以使用递归</rich_text></node><node name="bak" prog_lang="cpp" readonly="False" tags="" unique_id="51"><rich_text></rich_text></node></node><node name="kernel" prog_lang="custom-colors" readonly="False" tags="" unique_id="45"><rich_text link="webs http://blog.jobbole.com/54833/">http://blog.jobbole.com/54833/</rich_text><rich_text>
</rich_text></node><node name="ffmpeg" prog_lang="custom-colors" readonly="False" tags="" unique_id="8"><rich_text>1. ffmpeg snapshot，一秒二次

        ffmpeg -y -i test.flv -q:v 1 -r 2 -ss 10 -to 50 s%05d.jpg
ffmpeg -pix_fmt uyvy422 -s 720x576 -r 25 -i all.yuv -b </rich_text><rich_text background="#000000000000">20480k</rich_text><rich_text> -f s16le -ar 48000 -ac 2 -i all.pcm -vcodec libx264 $d

ffmpeg -pix_fmt uyvy422 -s 720x480 -r 25 -i all.yuv -b 20480k -f s16le -ar 48000 -ac 2 -i all.pcm -vcodec libx264 $d
</rich_text><node name="ffmpeg SDK" prog_lang="custom-colors" readonly="False" tags="ffmpeg" unique_id="39"><rich_text>
ffmpeg SDK </rich_text><rich_text link="webs http://ffmpeg.org/doxygen/trunk/index.html">http://ffmpeg.org/doxygen/trunk/index.html</rich_text><rich_text>
1.
</rich_text><rich_text justification="left"></rich_text><rich_text>/**

2. 
</rich_text><rich_text justification="left"></rich_text><rich_text>
</rich_text><codebox char_offset="58" frame_height="200" frame_width="100" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="cpp" width_in_pixels="False">/**
 * Initialize libavformat and register all the muxers, demuxers and
 * protocols. If you do not call this function, then you can select
 * exactly which formats you  want to support.
 *
 * @see av_register_input_format()
 * @see av_register_output_format()
 *  call in first
 */
 void av_register_all(void);</codebox><codebox char_offset="68" frame_height="200" frame_width="100" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="cpp" width_in_pixels="False">/** Open a input stream and readn the header.The codecs are not opened. 
 * NOTE: options is not NULL if the file is   videofile 
 */
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options);  </codebox></node></node><node name="python" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="2"><rich_text></rich_text><node name="tips" prog_lang="custom-colors" readonly="False" tags="" unique_id="12"><rich_text>python web 
</rich_text><rich_text link="webs http://www.zackgrossbart.com/hackito/search-engine-python/">http://www.zackgrossbart.com/hackito/search-engine-python/</rich_text><rich_text>
tornado
</rich_text><rich_text link="webs http://blog.csdn.net/littlethunder/article/details/8930157">http://blog.csdn.net/littlethunder/article/details/8930157</rich_text><rich_text>
trondb
</rich_text><rich_text link="webs http://blog.csdn.net/littlethunder/article/details/8918045">http://blog.csdn.net/littlethunder/article/details/8918045</rich_text><rich_text>
django
</rich_text><rich_text link="webs http://blog.sina.com.cn/s/blog_634bc2230100h8au.html">http://blog.sina.com.cn/s/blog_634bc2230100h8au.html</rich_text><rich_text>


Getting Started with Django on Heroku
</rich_text><rich_text link="webs https://devcenter.heroku.com/articles/getting-started-with-django#prerequisites">https://devcenter.heroku.com/articles/getting-started-with-django#prerequisites</rich_text><rich_text>
Django Blog例子
</rich_text><rich_text link="webs http://markchen.me/django-instance-tutorial-blog-1/">http://markchen.me/django-instance-tutorial-blog-1/</rich_text><rich_text>


python tips 一人一python
</rich_text><rich_text link="webs http://www.pythontip.com/blog/all_cat/">http://www.pythontip.com/blog/all_cat/</rich_text><rich_text>


reqiest and response object (Django)
</rich_text><rich_text link="webs https://docs.djangoproject.com/en/1.5//ref/request-response/">https://docs.djangoproject.com/en/1.5//ref/request-response/</rich_text><rich_text>


python 文章
</rich_text><rich_text link="webs http://django-china.cn/topic/173/">http://django-china.cn/topic/173/</rich_text><rich_text>

python 多线程
</rich_text><rich_text link="webs http://blog.jobbole.com/52060/">http://blog.jobbole.com/52060/</rich_text><rich_text> 


python xml dom 
</rich_text><rich_text link="webs http://www.w3schools.com/dom/dom_nodes_set.asp">http://www.w3schools.com/dom/dom_nodes_set.asp</rich_text><rich_text> 
</rich_text></node><node name="collections" prog_lang="python" readonly="False" tags="" unique_id="44"><rich_text>1. python 生成 随机字符串:
import random
import string
salt = ''.join(random.sample(string.ascii_letters+string.digits, 8))
2. unix get disk space info
import os
from collections
import namedtuple 
_ntuple_diskusage = namedtuple('usage','total used free') 
def disk_usage(path):    
    &quot;&quot;&quot;Return disk usage statistics about the given path.        
    Returned valus is a named tuple with attributes 'total', 'used' and            
    'free', which are the amount of total, used and free space, in bytes.        
    &quot;&quot;&quot;       
    st=os.statvfs(path)       
    free=st.f_bavail*st.f_frsize        
    total=st.f_blocks*st.f_frsize        
    used=(st.f_blocks-st.f_bfree)*st.f_frsize        
return _ntuple_diskusage(total,used,free)

3. dict and list 
Python  中的字典使用了hast，因此，在查找中需要遍历整个list的情况，最好把list转为dict

from time import time
t=time()
list=['a','b','is','python','jason','hello','hill','with','phone','test',
'dfdf','apple','pddf','ind','basic','none','baecr','var','bana','dd','wrd']
 #list = dict.fromkeys(list,True)
printlist
filter=[]
 foriinrange(1000000):
     forfindin['is','hat','new','list','old','.']:
         iffindnotinlist:
             filter.append(find)
 print&quot;total run time:&quot;
 printtime()-t
 
 
 4.使用set求交集
 
 fromtimeimporttime
 t=time()
 lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]
 listb=[2,4,6,9,23]
 intersection=[]
 foriinrange(1000000):
     list(set(lista)&amp;set(listb))
 print&quot;total run time:&quot;
 printtime()-t
 
 5.对循环的优化
尽量把循环中的计算放到上一层中，用xrange代替range

7.充分利用 Lazy if-evaluation 的特性
8.字符串的优化
a。字符串的连接尽量使用join而不是‘+’，
     同时尽量使用  
        slit = [func(e) for e in elist]

        x = &quot;&quot;.join(slit)
当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))

对字符进行格式化比直接串联读取要快，因此要使用

out=&quot;%s%s%s%s&quot;%(head, prologue, query, tail)


9,使用列表解析和生成器表达式
a=[i for i in list]   g = (i for i in list)
10 if done is not None 比语句 if done != None 更快



[i for i in enumerate(l)]
 [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]</rich_text></node></node><node name="Linux" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="3"><rich_text></rich_text><node name="shell" prog_lang="custom-colors" readonly="False" tags="" unique_id="9"><rich_text>find &lt;CONDITION to Find files&gt; -exec &lt;OPERATION&gt; \;
find -mmin -60 -exec ls -l {} \;

redirect io to null 
command &gt; /dev/null 1&gt;2&amp;

1.   set -u，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的set -o nounset

2. 
</rich_text><rich_text justification="left"></rich_text><rich_text>




防止脚本重复运行方法



main(){
selfPID=&quot;$$&quot;
scriptFile=&quot;$0&quot;
 
typeset existingPid
existingPid=`getExistingPIDs $selfPID &quot;$scriptFile&quot;`
 
if [ ! -z &quot;$existingPid&quot; ]; then
  echo &quot;The script already running, exiting...&quot;
  exit -1
fi
 
doItsTask
 
}
 
#获取除本身进程以外其它运行当前脚本的进程的 PID
getExistingPIDs(){
selfPID=&quot;$1&quot;
scriptFile=&quot;$2&quot;
 
ps -ef | grep &quot;/usr/bin/ksh ${scriptFile}&quot; | grep -v &quot;grep&quot; | awk &quot;{ if(\$2!=$selfPID) print \$2 }&quot;
}
 
doItsTask(){
echo &quot;Task is now being executed...&quot;
sleep 20  #睡眠 20s，以模拟脚本在执行需要长时间完成的任务
}
 
main $*


</rich_text><codebox char_offset="202" frame_height="500" frame_width="100" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="cpp" width_in_pixels="False"> 八进制转十进制：

[chengmo@centos5 ~]$ ((num=0123));
[chengmo@centos5 ~]$ echo $num;
83

[chengmo@centos5 ~]$ ((num=8#123));
[chengmo@centos5 ~]$ echo $num;
83
一、Linux shell 截取字符变量的前8位，有方法如下：
　　1.expr substr “$a” 1 8
　　2.echo $a|awk ‘{print substr(,1,8)}’
　　3.echo $a|cut -c1-8
　　4.expr $a : ‘\(.\\).*’
　　5.echo $a|dd bs=1 count=8 2&gt;/dev/null
　　二、按指定的字符串截取
　　1、第一种方法: 
　　${varible##*string} 从左向右截取最后一个string后的字符串 
　　${varible#*string}从左向右截取第一个string后的字符串 
　　${varible%%string*}从右向左截取最后一个string后的字符串 
　　${varible%string*}从右向左截取第一个string后的字符串 “*”只是一个通配符可以不要
例子： $ MYVAR=foodforthought.jpg $ echo ${MYVAR##*fo} rthought.jpg $ echo ${MYVAR#*fo} odforthought.jpg
　　2、第二种方法：
　　${varible:n1:n2}:截取变量varible从n1到n2之间的字符串。
可以根据特定字符偏移和长度，使用另一种形式的变量扩展，来选择特定子字符串。试着在 bash 中输入以下行： $ EXCLAIM=cowabunga $ echo ${EXCLAIM:0:3} cow $ echo ${EXCLAIM:3:7} abunga
这种形式的字符串截断非常简便，只需用冒号分开来指定起始字符和子字符串长度。
三、按照指定要求分割： 比如获取后缀名 ls -al | cut -d “.” -f2</codebox><node name="常用脚本" prog_lang="custom-colors" readonly="False" tags="" unique_id="10"><rich_text>1、查看主机网卡流量#!/bin/bash
#!/bin/bash#network#Mike.Xuwhile : ; do      time='date +%m&quot;-&quot;%d&quot; &quot;%k&quot;:&quot;%M'      day='date +%m&quot;-&quot;%d'      rx_before='ifconfig eth0|sed -n &quot;8&quot;p|awk '{print $2}'|cut -c7-'      tx_before='ifconfig eth0|sed -n &quot;8&quot;p|awk '{print $6}'|cut -c7-'      sleep 2      rx_after='ifconfig eth0|sed -n &quot;8&quot;p|awk '{print $2}'|cut -c7-'      tx_after='ifconfig eth0|sed -n &quot;8&quot;p|awk '{print $6}'|cut -c7-'      rx_result=$[(rx_after-rx_before)/256]      tx_result=$[(tx_after-tx_before)/256]      echo &quot;$time Now_In_Speed: &quot;$rx_result&quot;kbps Now_OUt_Speed: &quot;$tx_result&quot;kbps&quot;      sleep 2donedone2、系统状况监控#!/bin/sh#systemstat.sh#Mike.XuIP=192.168.1.227top -n 2| grep &quot;Cpu&quot; &gt;&gt;./temp/cpu.txtfree -m | grep &quot;Mem&quot; &gt;&gt; ./temp/mem.txtdf -k | grep &quot;sda1&quot; &gt;&gt; ./temp/drive_sda1.txt#df -k | grep sda2 &gt;&gt; ./temp/drive_sda2.txtdf -k | grep &quot;/mnt/storage_0&quot; &gt;&gt; ./temp/mnt_storage_0.txtdf -k | grep &quot;/mnt/storage_pic&quot; &gt;&gt; ./temp/mnt_storage_pic.txttime=`date +%m&quot;.&quot;%d&quot; &quot;%k&quot;:&quot;%M`connect=`netstat -na | grep &quot;219.238.148.30:80&quot; | wc -l`echo &quot;$time  $connect&quot; &gt;&gt; ./temp/connect_count.txt



3、监控主机的磁盘空间，当使用空间超过90％就通过发mail来发警告


#!/bin/bash#monitor available disk spaceSPACE='df | sed -n '/ \ / $ / p' | gawk '{print $5}' | sed  's/%//'if [ $SPACE -ge 90 ]thenfty89@163.comfi


4、 监控CPU和内存的使用情况


#!/bin/bash#script  to capture system statisticsOUTFILE=/home/xu/capstats.csvDATE='date +%m/%d/%Y'TIME='date +%k:%m:%s'TIMEOUT='uptime'VMOUT='vmstat 1 2' USERS='echo $TIMEOUT | gawk '{print $4}' 'LOAD='echo $TIMEOUT | gawk '{print $9}' | sed &quot;s/,//' 'FREE='echo $VMOUT | sed -n '/[0-9]/p' | sed -n '2p' | gawk '{print $4} ' 'IDLE='echo  $VMOUT | sed -n '/[0-9]/p' | sed -n '2p' |gawk '{print $15}' 'echo &quot;$DATE,$TIME,$USERS,$LOAD,$FREE,$IDLE&quot; &gt;&gt; $OUTFILE


5、全方位监控主机


#!/bin/bash# check_xu.sh# 0 * * * * /home/check_xu.sh DAT=&quot;`date +%Y%m%d`&quot;HOUR=&quot;`date +%H`&quot;DIR=&quot;/home/oslog/host_${DAT}/${HOUR}&quot;DELAY=60COUNT=60# whether the responsible directory existif ! test -d ${DIR}then        /bin/mkdir -p ${DIR}fi# general checkexport TERM=linux/usr/bin/top -b -d ${DELAY} -n ${COUNT} &gt; ${DIR}/top_${DAT}.log 2&gt;&amp;1 &amp;# cpu check/usr/bin/sar -u ${DELAY} ${COUNT} &gt; ${DIR}/cpu_${DAT}.log 2&gt;&amp;1 &amp;#/usr/bin/mpstat -P 0 ${DELAY} ${COUNT} &gt; ${DIR}/cpu_0_${DAT}.log 2&gt;&amp;1 &amp;#/usr/bin/mpstat -P 1 ${DELAY} ${COUNT} &gt; ${DIR}/cpu_1_${DAT}.log 2&gt;&amp;1 &amp;# memory check/usr/bin/vmstat ${DELAY} ${COUNT} &gt; ${DIR}/vmstat_${DAT}.log 2&gt;&amp;1 &amp;# I/O check/usr/bin/iostat ${DELAY} ${COUNT} &gt; ${DIR}/iostat_${DAT}.log 2&gt;&amp;1 &amp;# network check/usr/bin/sar -n DEV ${DELAY} ${COUNT} &gt; ${DIR}/net_${DAT}.log 2&gt;&amp;1 &amp;#/usr/bin/sar -n EDEV ${DELAY} ${COUNT} &gt; ${DIR}/net_edev_${DAT}.log 2&gt;&amp;1 &amp;</rich_text></node></node><node name="collections" prog_lang="custom-colors" readonly="False" tags="" unique_id="21"><rich_text>Linux

Linux下用jq来格式化json，相当NB
使用vimdiff作为svn diff的查看代码工具

</rich_text><rich_text link="webs http://color/#3465A4">http://www.cnblogs.com/xuxm2007/archive/2012/05/11/2496243.html</rich_text><rich_text>


</rich_text><rich_text weight="heavy">Linux 常用快捷键core文件设置</rich_text><rich_text>
linux下默认是不产生core文件的，要用ulimit -c unlimited放开
1、开启系统的Core Dump功能

   ulimit -c core_file_size_in_kb

   如果要关闭该功能core_file_size_in_kb为0就行了。

2、设置Core Dump的核心转储文件目录和命名规则

   文件的命名规则放在

   </rich_text><rich_text link="webs http://color/#3465A4">/proc/sys/kernel/core_name_format文件中</rich_text><rich_text>

   使用sysctl -w &quot;kernel.core_name_format=/coredump/%n.core&quot;

   上例的core文件放在/coredump目录下，文件名是进程名+.core

   以下是一些命名的格式说明

   %P   The Process ID (current-&gt;pid)
   %U   The UID of the process (current-&gt;uid)
   %N   The command name of the process (current-&gt;comm)
   %H   The nodename of the system (system_utsname.nodename)
   %%   A &quot;%&quot;



|/usr/share/apport/apport %p %s %c

</rich_text><rich_text weight="heavy">设置默认编辑器</rich_text><rich_text>
  update-alternatives --config editor


dd if=1375752413.742425.data bs=32 skip=1 of=1.flac
</rich_text><rich_text link="webs http://blog.csdn.net/androidyue/article/details/9295505">Ubuntu 12.04 如何修改背景色         http://blog.csdn.net/androidyue/article/details/9295505</rich_text><rich_text>sshfs
sshfs root@livedev:/opt tmp




find &lt;CONDITION to Find files&gt; -exec &lt;OPERATION&gt; \;
find -mmin -60 -exec ls -l {} \;

重定向
redirect io to null 
command &gt; /dev/null 2&gt;&amp;1


</rich_text><rich_text scale="h1">修改时区 时间 等</rich_text><rich_text>

dpkg-reconfigure timezonecon
dpkg-reconfigure tzdata
sudo cp /usr/share/zoneinfo/Asia/ShangHai /etc/localtime
sudo ntpdate cn.pool.ntp.org




</rich_text><rich_text scale="h1">解压deb包</rich_text><rich_text>

dpkg-deb -x xxxx.deb di



curl 
curl --data-binary '@post_data.txt' </rich_text><rich_text link="webs http://192.168.100.228:8080/sendTasks">http://192.168.100.228:8080/sendTasks</rich_text><rich_text>

Linux 修改键盘配置
xev    xmdom -pke


 xmodmap -e &quot;keycode 180 = Escape NoSymbol Escape&quot;


curl
curl -d '@task' &quot;http://192.168.1.50:8080/jobTracker/task/submit&quot; -H&quot;Content-Type:application/json&quot;

Linux 修改 crontab 编辑器
update-alternatives --config editor

1. 查看一个系统可以打开的文件的个数        cat /proc/sys/fs/file-max





sshfs is an easy way to provide file access to a remote system with ssh. On Ubuntu, all you need to install it (on the remote client, nothing to do on the server if it already runs ssh) is run:
sudo apt-get install sshfs
To make things easier, you can make an /etc/fstab entry with the settings to mount a remote directory:
sshfs#chip@example.unicom.com:/home/chip /home/chip/Remote-Home fuse umask=0,defaults,noauto,user 0 0
Now, to mount the directory I just type (from my home directory):
$ </rich_text><rich_text weight="heavy">mount Remote-Home</rich_text><rich_text>
The problem is that if I try to unmount the directory it fails:
$ </rich_text><rich_text weight="heavy">umount Remote-Home</rich_text><rich_text>
umount: /home/chip/Remote-Home mount disagrees with the fstab
The command you have to use is:
$ </rich_text><rich_text weight="heavy">fusermount -u Remote-Home
</rich_text><rich_text>But you can make umount work with two simple steps.
First (this is the trick), run:
$ </rich_text><rich_text weight="heavy">sudo ln -s mount.fuse mount.fuse.sshfs</rich_text><rich_text>
Then, make two changes to the fstab file. First, change the filesystem type (column three) from fuse to fuse.sshfs. Then, remove &quot;sshfs#&quot; from the first field. Now, it will look something like:
chip@example.unicom.com:/home/chip /home/chip/Remote-Home fuse.sshfs umask=0,defaults,noauto,user 0 0
Now, everything will work as desired.
$ </rich_text><rich_text weight="heavy">mount Remote-Home</rich_text><rich_text>
 .
 .
 .
$ </rich_text><rich_text weight="heavy">umount -v Remote-Home</rich_text><rich_text>
chip@example.unicom.com:/home/chip umounted
 
 
sshfs root@livedev:/opt tmp

查看 Linux版本 cat /etc/issue

</rich_text><rich_text justification="left"></rich_text><rich_text>

进程内存
查看目前进程正在实际被使用的内存，是used-(buffers+cache)，也可以认为如果swap没有大量使用，mem还是够用的，只有mem被当前进程实际占用完（没有了buffers和cache），才会使用到swap的。

在清空缓存前我们需要在linux系统中执行一下sync命令，将缓存中的未被写入磁盘的内容写到磁盘上
释放方法有三种（系统默认值是0，释放之后你可以再改回0值）：
To free pagecache:  echo 1 &gt; /proc/sys/vm/drop_caches
To free dentries and inodes:  echo 2 &gt; /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:  echo 3 &gt; /proc/sys/vm/drop_caches
 





</rich_text><codebox char_offset="3012" frame_height="500" frame_width="100" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="sh" width_in_pixels="False">sed 的一些命令

+ :：:label，标志一个label，用于b/t的跳转
+ =：[address]= 打印出行号
+ a：[address]a\ append text to this line.
+ b：[address[,address]]b[label] 条件分支语句
+ c：[address[,address]]c\ 替换内容
+ d：[address[,address]]d 删除pattern中的所有行，并读入下一新行到pattern中
+ D：[address[,address]]D 删除multiline pattern中的第一行，不读入下一行
+ g：[address[,address]]g 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除
+ G：[address[,address]]G 将hold space中的内容append到pattern space\n后
+ h：[address[,address]]h 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除
+ H：[address[,address]]H 将pattern space中的内容append到hold space\n后
+ i：[address]i\ 在address行的前面插入文字，和a反义
+ l：[address[,address]]l 打印pattern space中的内容，不可打印字符打印出ascii
+ n：[address[,address]]n 输出pattern space中的内容，读入下一新行替换掉原来的行
+ N：[address[,address]]N 读入下一行形成multiline pattern，用于跨行处理
+ p：[address[,address]]p 打印出pattern space中的内容
+ P：[address[,address]]P 打印出multiline pattern space中的第一行
+ q：[address]q 碰到address行时退出sed script
+ r：[address]r file 将文件file的内容append到pattern space后
+ s：[address[,address]]s/pattern/replace/[flag] 将pattern替换成replace.flag:
+ n：替换第n个出现的pattern,默认是第一个出现的pattern
+ g：全部替换pattern
+ p：如果替换成功则打印
+ w file：将替换的行写入到文件里
+ t：[address[,address]]t [label] 如果替换成功则跳转
+ w：[address[,address]]w file 将pattern中的内容追加写到file文件
+ x：[address[,address]]x 交换hold space和pattern space的内容
+ y：[address1[,address2]]y/abc/xyz/ 将abc转换为对应的xyz


sed -n '/([0-9]{1,3}.){3}[0-9]{1,3}/p' IP.txt #查找IP
sed -i &quot;s#([0-9]{1,3}.){3}[0-9]{1,3}:([0-9]){1,4}#${IPPORT}#g&quot; &quot;$FILE&quot;

sed -e &quot;/^[A-Za-z_][A-Za-z0-9_]* [A-Za-z_][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*(/=&quot; tttt #在tttt中查找类似UINT32 MyClass::setMyClass所在的行号

sed -e ':K;N;s/n/ /;bK' t #合并所有行，使用的label
sed -e 'N;s/n/ /g' t #合并两行

sed '3{h;d}; 5{G}' ＃交换3，5行， h,d,G
top -p 2222 -b &gt;txt&amp; #后台监控2222进程



strftime 将时间戳转日期
awk 'BEGIN{print strftime(&quot;%Y-%m-%d&quot;,systime())}'

将日期转为时间戳
awk 'BEGIN {printf(&quot;%dn&quot;,mktime(2006&quot; &quot;8&quot; &quot;5&quot; &quot;15&quot; &quot;09&quot; &quot;0))}'

awk 'BEGIN {printf(&quot;%dn&quot;,mktime(&quot;2014&quot; &quot;1&quot; &quot;2&quot; &quot;01&quot; &quot;36&quot; &quot;0&quot;))}'
vim -&gt; 其他程序
&quot;*y

其他程序-&gt;gvim
“*p </codebox></node><node name="screen" prog_lang="custom-colors" readonly="False" tags="screen" unique_id="36"><rich_text style="italic">screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]
Screen命令参数：</rich_text><rich_text>
-A -[r|R]          将所有的视窗都调整为目前终端机的大小。
-c filename        用指定的filename文件替代screen的配置文件’.screenrc’.
-d [pid.tty.host]  断开screen进程(使用该命令时，screen的状态一定要是Attached，也就是说有用户连在screen里)。一般进程的名字是以pid.tty.host这种形式表示(用screen -list命令可以看出状态)。
-D [pid.tty.host]  与-d命令实现一样的功能，区别就是如果执行成功，会踢掉原来在screen里的用户并让他logout。
-h &lt;行数&gt; 　       指定视窗的缓冲区行数。

-ls或–list        显示目前所有的screen作业。
-m                    即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-p number or name  预先选择一个窗口。
-r [pid.tty.host]  恢复离线的screen进程，如果有多个断开的进程，需要指定[pid.tty.host]
-R                      先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s shell             指定建立新视窗时，所要执行的shell。
-S &lt;作业名称&gt;  指定screen作业的名称。(用来替代[pid.tty.host]的命名方式,可以简化操作).
-v                     显示版本信息。
-wipe                检查目前所有的screen作业，并删除已经无法使用的screen作业。
-x                     恢复之前离线的screen作业。

Screen命令的常规用法:

screen -d -r:连接一个screen进程，如果该进程是attached，就先踢掉远端用户再连接。

screen -D -r:连接一个screen进程，如果该进程是attached，就先踢掉远端用户并让他logout再连接

screen -ls或者-list:显示存在的screen进程，常用命令

screen -m:如果在一个Screen进程里，用快捷键crtl+a c或者直接打screen可以创建一个新窗口,screen -m可以新建一个screen进程。

screen -dm:新建一个screen，并默认是detached模式，也就是建好之后不会连上去。

screen -p number or name:预先选择一个窗口。

Screen实现后台运行程序的简单步骤:

1&gt; 要进行某项操作时，先使用命令创建一个Screen:
[linux@user~]$ screen -S test1

2&gt;接着就可以在里面进行操作了，如果你的任务还没完成就要走开的话，使用命令保留Screen：
[linux@user~]$ Ctrl+a+d                    #按Ctrl+a，然后再按d即可保留Screen
[detached]                                 #这时会显示出这个提示，说明已经保留好Screen了

如果你工作完成的话，就直接输入:
[linux@user~]$ exit                        #这样就表示成功退出了
[screen is terminating]

3&gt; 如果你上一次保留了Screen，可以使用命令查看：
[linux@user~]$ screen -ls
There is a screen on:
9649.test1   (Detached)

恢复Screen，使用命令：
[linux@user~]$ screen -r test1 (or 9649)

Screen命令中用到的快捷键

Ctrl+a c ：创建窗口

Ctrl+a w ：窗口列表

Ctrl+a n ：下一个窗口

Ctrl+a p ：上一个窗口

Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换

Ctrl+a K(大写) ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态）

exit ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态）

Ctrl+a d ：退出当前终端，返回加载screen前的shell命令状态
</rich_text></node><node name="core文件设置" prog_lang="custom-colors" readonly="False" tags="core" unique_id="37"><rich_text>Linux


使用vimdiff作为svn diff的查看代码工具

</rich_text><rich_text link="webs http://color:#3465A4" weight="heavy">http://www.cnblogs.com/xuxm2007/archive/2012/05/11/2496243.html</rich_text><rich_text weight="heavy">Linux 常用快捷键core文件设置</rich_text><rich_text>
 linux下默认是不产生core文件的，要用ulimit -c unlimited放开
1、开启系统的Core Dump功能

    ulimit -c core_file_size_in_kb

    如果要关闭该功能core_file_size_in_kb为0就行了。

2、设置Core Dump的核心转储文件目录和命名规则

    文件的命名规则放在

    </rich_text><rich_text link="webs http://color:#3465A4">/proc/sys/kernel/core_name_format文件中</rich_text><rich_text>

    使用sysctl -w &quot;kernel.core_name_format=/coredump/%n.core&quot;

    上例的core文件放在/coredump目录下，文件名是进程名+.core

    以下是一些命名的格式说明

    %P   The Process ID (current-&gt;pid)
    %U   The UID of the process (current-&gt;uid)
    %N   The command name of the process (current-&gt;comm)
    %H   The nodename of the system (system_utsname.nodename)
    %%   A &quot;%&quot;

</rich_text><rich_text weight="heavy">设置默认编辑器</rich_text><rich_text>
   update-alternatives --config editor


 dd if=1375752413.742425.data bs=32 skip=1 of=1.flac</rich_text></node><node name="Linux 常用" prog_lang="custom-colors" readonly="False" tags="快捷键 " unique_id="23"><rich_text>
• # ctrl + l - 清屏 
• # ctrl + c - 终止命令
• # ctrl + d - 退出 shell，好像也可以表示EOF
• # ctrl + z - 将当前进程置于后台，fg还原。 
• # ctrl + r - 从命令历史中找 
• # ctrl + a - 光标移到行首 
• # ctrl + e - 光标移到行尾
• # ctrl + u - 清除光标到行首的字符 
• # ctrl + w - 清除光标之前一个单词 
• # ctrl + k - 清除光标到行尾的字符
• # ctrl + t - 交换光标前两个字符 
• # ctrl + y - 粘贴前一ctrl+u类命令删除的字符
• # ctrl + p - 上一条命令
• # ctrl + n - 下一条命令 
• # ctrl + v - 输入控制字符 如ctrl+v &lt;ENTER&gt; ,会输入^M 
• # ctrl + f - 光标后移一个字符
• # ctrl + b - 光标前移一个字符 
• # ctrl + h - 删除光标前一个字符 
• # N+&lt;ESC&gt;+f - 光标后移N个单词，N为1时可省略
• # N+&lt;ESC&gt;+b - 光标前移N个单词，N为1时可省略 
• # ctrl + s - 挂起当前shell
• # ctrl + q - 重新启用
• # &lt;ESC&gt;+d 从光标开始处删除到行尾。挂起的shell 
• # !! - 上一条命令 
• # !-n - 倒数第N条历史命令 
• # !-n:p - 打印上一条命令（不执行） 
• # !?string？- 最新一条含有“string”的命令 # !-n:gs/str1/str2/ - 将倒数第N条命令的str1替换为str2，并执行（若不加g,则仅替换第一个）

do date -d &quot;$a&quot; +%s;

atop -r xxx to view  atop log  t or shit_t can move forward/backward</rich_text><node name="screen" prog_lang="custom-colors" readonly="False" tags="screen" unique_id="24"><rich_text style="italic">screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]
Screen命令参数：</rich_text><rich_text>
-A -[r|R]          将所有的视窗都调整为目前终端机的大小。
-c filename        用指定的filename文件替代screen的配置文件’.screenrc’.
-d [pid.tty.host]  断开screen进程(使用该命令时，screen的状态一定要是Attached，也就是说有用户连在screen里)。一般进程的名字是以pid.tty.host这种形式表示(用screen -list命令可以看出状态)。
-D [pid.tty.host]  与-d命令实现一样的功能，区别就是如果执行成功，会踢掉原来在screen里的用户并让他logout。
-h &lt;行数&gt; 　       指定视窗的缓冲区行数。

-ls或–list        显示目前所有的screen作业。
-m                    即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-p number or name  预先选择一个窗口。
-r [pid.tty.host]  恢复离线的screen进程，如果有多个断开的进程，需要指定[pid.tty.host]
-R                      先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s shell             指定建立新视窗时，所要执行的shell。
-S &lt;作业名称&gt;  指定screen作业的名称。(用来替代[pid.tty.host]的命名方式,可以简化操作).
-v                     显示版本信息。
-wipe                检查目前所有的screen作业，并删除已经无法使用的screen作业。
-x                     恢复之前离线的screen作业。

Screen命令的常规用法:

screen -d -r:连接一个screen进程，如果该进程是attached，就先踢掉远端用户再连接。

screen -D -r:连接一个screen进程，如果该进程是attached，就先踢掉远端用户并让他logout再连接

screen -ls或者-list:显示存在的screen进程，常用命令

screen -m:如果在一个Screen进程里，用快捷键crtl+a c或者直接打screen可以创建一个新窗口,screen -m可以新建一个screen进程。

screen -dm:新建一个screen，并默认是detached模式，也就是建好之后不会连上去。

screen -p number or name:预先选择一个窗口。

Screen实现后台运行程序的简单步骤:

1&gt; 要进行某项操作时，先使用命令创建一个Screen:
[linux@user~]$ screen -S test1

2&gt;接着就可以在里面进行操作了，如果你的任务还没完成就要走开的话，使用命令保留Screen：
[linux@user~]$ Ctrl+a+d                    #按Ctrl+a，然后再按d即可保留Screen
[detached]                                 #这时会显示出这个提示，说明已经保留好Screen了

如果你工作完成的话，就直接输入:
[linux@user~]$ exit                        #这样就表示成功退出了
[screen is terminating]

3&gt; 如果你上一次保留了Screen，可以使用命令查看：
[linux@user~]$ screen -ls
There is a screen on:
9649.test1   (Detached)

恢复Screen，使用命令：
[linux@user~]$ screen -r test1 (or 9649)

Screen命令中用到的快捷键

Ctrl+a c ：创建窗口

Ctrl+a w ：窗口列表

Ctrl+a n ：下一个窗口

Ctrl+a p ：上一个窗口

Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换

Ctrl+a K(大写) ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态）

exit ：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该终端自动终止，并且退回到原始shell状态）

Ctrl+a d ：退出当前终端，返回加载screen前的shell命令状态
</rich_text></node><node name="core文件设置" prog_lang="custom-colors" readonly="False" tags="core" unique_id="25"><rich_text>Linux


使用vimdiff作为svn diff的查看代码工具

</rich_text><rich_text link="webs http://color:#3465A4" weight="heavy">http://www.cnblogs.com/xuxm2007/archive/2012/05/11/2496243.html</rich_text><rich_text weight="heavy">Linux 常用快捷键core文件设置</rich_text><rich_text>
 linux下默认是不产生core文件的，要用ulimit -c unlimited放开
1、开启系统的Core Dump功能

    ulimit -c core_file_size_in_kb

    如果要关闭该功能core_file_size_in_kb为0就行了。

2、设置Core Dump的核心转储文件目录和命名规则

    文件的命名规则放在

    </rich_text><rich_text link="webs http://color:#3465A4">/proc/sys/kernel/core_name_format文件中</rich_text><rich_text>

    使用sysctl -w &quot;kernel.core_name_format=/coredump/%n.core&quot;

    上例的core文件放在/coredump目录下，文件名是进程名+.core

    以下是一些命名的格式说明

    %P   The Process ID (current-&gt;pid)
    %U   The UID of the process (current-&gt;uid)
    %N   The command name of the process (current-&gt;comm)
    %H   The nodename of the system (system_utsname.nodename)
    %%   A &quot;%&quot;

</rich_text><rich_text weight="heavy">设置默认编辑器</rich_text><rich_text>
   update-alternatives --config editor


 dd if=1375752413.742425.data bs=32 skip=1 of=1.flac</rich_text></node><node name="vim常用 " prog_lang="custom-colors" readonly="False" tags="vim" unique_id="26"><rich_text weight="heavy">marker折叠方式时，我们需要用标计来标识代码的折叠，系统默认是{{{和}}}• 折叠命令</rich_text><rich_text>
• 
• zf　创建折叠，比如在marker方式下：
•         zf56G，创建从当前行起到56行的代码折叠；
•         10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。
•         10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。
•         在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），{}，[]，&lt;&gt;等）。
• zd  删除 (delete) 在光标下的折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。
• zD  循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。
• zE  除去 (Eliminate) 窗口里“所有”的折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。

</rich_text><rich_text weight="heavy">:r !ls 会把执行的命令导入到vim中</rich_text><rich_text>


</rich_text></node><node name="ffmpeg" prog_lang="custom-colors" readonly="False" tags="ffmpeg" unique_id="27"><rich_text>ffmpeg -i tt.mp4 -vn -strict -2 audio.mp4

1. ffmpeg snapshot，一秒二次

        ffmpeg -y -i test.flv -q:v 1 -r 2 -ss 10 -to 50 s%05d.jpg
ffmpeg -pix_fmt uyvy422 -s 720x576 -r 25 -i all.yuv -b 20480k -f s16le -ar 48000 -ac 2 -i all.pcm -vcodec libx264 $d

ffmpeg -pix_fmt uyvy422 -s 720x480 -r 25 -i all.yuv -b 20480k -f s16le -ar 48000 -ac 2 -i all.pcm -vcodec libx264 $d



ffmpeg -pix_fmt uyvy422 -s 720x480 -r 29.97 -i 1388659600059.yuv -b 20480k -vcodec libx264 t.avi


前20 s为空白
 1. 提取audio 
 ffmpeg -y -i test.mpg -vn a.mpg
 1. 提取video
 ffmpeg -y -i test.mpg -an v.mpg
3.
3.1 生成 空白音频
ffmpeg -y -i /dev/zero -ar 44100 -ac 2 empty.mpg
注：这个过程是很快的， 只要大于20s了就可以停了。 44100, 2分别是a.mpg的bit rate, channels, 可以通过mediainfo a.mpg查看
3.2 取20s的空白音频 
ffmpeg -y -i empty.mpg -ss 0 -t 20  -codec copy e.mpg


4. concat e.mpg and a.mpg 
 ffmpeg -y -f concat  -i audio.merg -codec copy a2.mpg

audio.merg is a file like :​
li_yun@ubuntu:~/24$ 
cat audio.merg 
file e.mpg
file a2.mpg
5. merge audio and video file :
6. ffmpeg -i a2.mpg -i v.mpg -codec copy l.mpg 
l.mpg is file U want, first 20 seconds is silent!
</rich_text></node></node><node name="sed" prog_lang="sh" readonly="False" tags="sed" unique_id="43"><rich_text>sed 的一些命令

+ :：:label，标志一个label，用于b/t的跳转
+ =：[address]= 打印出行号
+ a：[address]a\ append text to this line.
+ b：[address[,address]]b[label] 条件分支语句
+ c：[address[,address]]c\ 替换内容
+ d：[address[,address]]d 删除pattern中的所有行，并读入下一新行到pattern中
+ D：[address[,address]]D 删除multiline pattern中的第一行，不读入下一行
+ g：[address[,address]]g 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除
+ G：[address[,address]]G 将hold space中的内容append到pattern space\n后
+ h：[address[,address]]h 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除
+ H：[address[,address]]H 将pattern space中的内容append到hold space\n后
+ i：[address]i\ 在address行的前面插入文字，和a反义
+ l：[address[,address]]l 打印pattern space中的内容，不可打印字符打印出ascii
+ n：[address[,address]]n 输出pattern space中的内容，读入下一新行替换掉原来的行
+ N：[address[,address]]N 读入下一行形成multiline pattern，用于跨行处理
+ p：[address[,address]]p 打印出pattern space中的内容
+ P：[address[,address]]P 打印出multiline pattern space中的第一行
+ q：[address]q 碰到address行时退出sed script
+ r：[address]r file 将文件file的内容append到pattern space后
+ s：[address[,address]]s/pattern/replace/[flag] 将pattern替换成replace.flag:
+ n：替换第n个出现的pattern,默认是第一个出现的pattern
+ g：全部替换pattern
+ p：如果替换成功则打印
+ w file：将替换的行写入到文件里
+ t：[address[,address]]t [label] 如果替换成功则跳转
+ w：[address[,address]]w file 将pattern中的内容追加写到file文件
+ x：[address[,address]]x 交换hold space和pattern space的内容
+ y：[address1[,address2]]y/abc/xyz/ 将abc转换为对应的xyz


sed -n '/([0-9]{1,3}.){3}[0-9]{1,3}/p' IP.txt #查找IP
sed -i &quot;s#([0-9]{1,3}.){3}[0-9]{1,3}:([0-9]){1,4}#${IPPORT}#g&quot; &quot;$FILE&quot;

sed -e &quot;/^[A-Za-z_][A-Za-z0-9_]* [A-Za-z_][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*(/=&quot; tttt #在tttt中查找类似UINT32 MyClass::setMyClass所在的行号

sed -e ':K;N;s/\n/ /;bK' t #合并所有行，使用的label
sed -e 'N;s/n/ /g' t #合并两行,多行类似

sed -e '3{h;d}; 5{G}' t #交换3，5行， h,d,G

sed  -e '2~2!d' t #保留偶数行

sed -e '1!G;h;$!d' t #倒置所有的行

sed -n '1!G;h;$p' t #倒置所有的行

sed  -e ':a;$q;N;11,$D;ba' t #只显示最后的10行</rich_text></node></node><node name="tools" prog_lang="custom-colors" readonly="False" tags="" unique_id="14"><rich_text>taskwarrior 
</rich_text><rich_text link="webs http://taskwarrior.org/projects/show/taskwarrior">http://taskwarrior.org/projects/show/taskwarrior</rich_text><rich_text>
javascript x86
</rich_text><rich_text link="webs http://bellard.org/jslinux/">http://bellard.org/jslinux/</rich_text><rich_text>
taobao code 据说有不少的C++
</rich_text><rich_text link="webs http://code.taobao.org/">http://code.taobao.org/</rich_text><rich_text>
wiki plantUML 

</rich_text><rich_text link="webs http://blog.csdn.net/ciaos/article/details/8501446">http://blog.csdn.net/ciaos/article/details/8501446</rich_text><rich_text>

</rich_text></node><node name="vim" prog_lang="custom-colors" readonly="False" tags="" unique_id="15"><rich_text>:earlier 1f直接恢复到上次写入
:set rnu 相对行号


http://vim.sourceforge.net/scripts/script_search_results.php?order_by=rating
</rich_text><node name="vim常用 " prog_lang="custom-colors" readonly="False" tags="vim" unique_id="38"><rich_text weight="heavy">marker折叠方式时，我们需要用标计来标识代码的折叠，系统默认是{{{和}}}• 折叠命令</rich_text><rich_text>
• 
• zf　创建折叠，比如在marker方式下：
•         zf56G，创建从当前行起到56行的代码折叠；
•         10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。
•         10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。
•         在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），{}，[]，&lt;&gt;等）。
• zd  删除 (delete) 在光标下的折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。
• zD  循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。
• zE  除去 (Eliminate) 窗口里“所有”的折叠。仅当 'foldmethod' 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。

</rich_text><rich_text weight="heavy">:r !ls 会把执行的命令导入到vim中</rich_text><rich_text>


</rich_text></node></node><node name="vobile" prog_lang="custom-colors" readonly="False" tags="" unique_id="16"><rich_text>./vdna_query -s 192.168.1.46 -u admin  -w admin123 -T dna --profile=Common -i 2.1387533947744.1387534303616.vdna -r t.xml
./vdna_query -s 192.168.1.46 -u admin  -w admin123 -T dna --profile=Common -i </rich_text><rich_text link="webs http://192.168.1.249/download/2.1388696339843.1388699999970.tgz">2.1388696339843.1388699999970.</rich_text><rich_text>vdna -r x.xml

</rich_text></node><node name="Myself" prog_lang="custom-colors" readonly="False" tags="" unique_id="17"><rich_text></rich_text><node name="TOREAD" prog_lang="custom-colors" readonly="False" tags="" unique_id="18"><rich_text>计算机类:
       SICP
      core algorithms deployed
       </rich_text><rich_text link="webs http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773">http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773</rich_text><rich_text>



LDD3          Linux Device Driver 3rd
LKD3          Linux Kernel Development 3rd
ULK3          Understanding the Linux Kernel 3rd
PLKA          Professional Linux Kernel Architecture
UML            User Mode Linux

Intel V3       Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B &amp; 3C): System Programming Guide



经济类:
    国富论
</rich_text><rich_text link="webs http://wenku.baidu.com/view/38ec644033687e21af45a9ae.html">http://wenku.baidu.com/view/38ec644033687e21af45a9ae.html</rich_text><rich_text>






文学类:
    王朔文集
</rich_text></node><node name="music" prog_lang="custom-colors" readonly="False" tags="" unique_id="19"><rich_text>Sitting Down here - LeneMarlin
The Game - Lunik
Chancenlos - Annett Louisan
Till I see you again - xx
Somersault - Courtney Jaye
人质 - 张惠妹
她来听我的演唱会 - 张学友
爱笑的眼睛 - 徐若暄
情歌王 - 古巨基
如果爱是一场婚礼 - 金巧巧
三个人的错误 - 王宛之
哭笑不得 - xx
阳光下的我们 - 
别找我麻烦 -
我在朋友婚礼上唱这首歌 - 徐海星
良人 - 邓芙茹
我们好像在哪见过 - 杨综纬
小狗圆舞曲 - 肖邦
</rich_text></node><node name="todo" prog_lang="custom-colors" readonly="False" tags="" unique_id="20"><rich_text>functional 
线程安全


wirte a script which vim can load tags which the open file is needed and lib script only, it depends file type too


寻找业余项目可以尝试从Elance、 oDesk或者Freelancer这些网站开始。

</rich_text></node><node name="work" prog_lang="custom-colors" readonly="False" tags="" unique_id="46"><rich_text></rich_text></node></node><node name="work" prog_lang="custom-colors" readonly="False" tags="" unique_id="47"><rich_text></rich_text><node name="TODO" prog_lang="custom-colors" readonly="False" tags="" unique_id="49"><rich_text>1. BlackMagic 卡的时间戳要要修改
1. 处理丢帧的情况, (Osprey 没有这种情况, Black Magic要考虑, )
2. 
TVAds tracker 使用python调用 C++的方法,把merge cdna的部分替换</rich_text></node></node><node name="Mysql" prog_lang="custom-colors" readonly="False" tags="" unique_id="11"><rich_text>1.  mysql show connections

2. mysql&gt; show status like '%onn%';

3. SHOW PROCESSLIST

4. SET NAMES 'utf8'    #mysql 设置编码



mysql&gt; select current_timestamp() ;

</rich_text></node><node name="git" prog_lang="custom-colors" readonly="False" tags="C++" unique_id="4"><rich_text>touch README.md git init git commit -m &quot;first commit&quot; git remote add origingit@github.com:szqh97/test.gitgit push -u origin master

1. git 恢复删除的文件 

        git checkout filename



http://blog.xupeng.me/2011/12/14/migrate-to-octopress/
</rich_text></node><node name="others" prog_lang="custom-colors" readonly="False" tags="others" unique_id="40"><rich_text weight="heavy">VOA</rich_text><rich_text>
</rich_text><rich_text style="italic">voa     mms://a1905.l211052072.c2110.g.lm.akamaistream.net/D/1905/2110/v0001/reflector:52072</rich_text><rich_text>

voa news mms://a823.l211056822.c2110.g.lm.akamaistream.net/d/823/2110/v0001/reflector:56822


grep &quot;Internal*&quot; -B1 tg|grep -v &quot;\-\-&quot;|sed '/xml\ stream/d'|sed 's/^.*\ post\ data\ is:\ //g'

find . -iname &quot;16.*.mp4&quot; -or -iname &quot;1.*.mp4&quot; -or -iname &quot;4.*.mp4&quot; | sed 's/\.\///g'|while read a; do r=`grep $a t`; if [ $r != 0 ] then echo $a &gt;&gt;t0306; fi; done

find . -iname &quot;16.*.mp4&quot; -or -iname &quot;1.*.mp4&quot; -or -iname &quot;4.*.mp4&quot; | sed 's/\.\///g'| while read a; do  grep $a t; if [ $? != 0 ]; then echo $a &gt;&gt; t0306; fi; done</rich_text></node><node name="vobile 常用" prog_lang="custom-colors" readonly="False" tags="vobile" unique_id="41"><rich_text>vobile 常用

</rich_text><rich_text weight="heavy">
1.vdna monitor sequence:</rich_text><rich_text>
processor-&gt;processor: pcm-&gt;flac

processor-&gt;dnaUploader:pcm,image
dnaUploader-&gt;webpy:POST

webpy-&gt;server: inotify
server-&gt;+acrserver: query
acrserver-&gt;-server: return
note over server: if success delete pcm,\nelse sav it.


state over A: Initial state
e here.



</rich_text><rich_text weight="heavy">2. wiki模板：</rich_text><rich_text>

= VDNALive 3.2.1 netStreaming  Detail Design =
修订记录

|| 版本号 || 日期 || 编写 || 审核 || 摘要 ||
|| 0.9 || 2013-08-12 || 李云 ||  || 初始化. ||

[[TOC()]]

## 结构定义 ##

### 模块总体结构定义 ###

 * 描述模块功能定义, 说明它在整个系统中的位置, 即与其他模块间的关联和依赖 关系.
 * 说明模块内部子模块划分, 调用方式, 依赖性和隔离性, 建议以结构图说明.

### 子模块1结构定义 ###

 * 说明子模块1的结构描述, 建议以结构图说明.
 * 说明子模块实现的函数或方法名称, 参数等.

## 流程定义 ##

### 流程1 ###

#### 流程描述和入口 ####
 
 * 描述流程入口, 确定模块的上层调用者.
 * 说明流程的特点(是否常驻内存、顺序处理还是并发处理、是可重入的还是不可 重入的等)

#### 主流程 ####

 * 输入: 定义该流程的输入参数的详细说明, 包括名称, 标识, 取值范围, 格式, 含义, 及参数间的顺序或依赖等关系.
 * 处理过程: 描述该流程在模块内部的处理过程, 建议用流程图, 或伪代码完成.
 * 输出: 定义该流程的输出参数的详细说明, 包括名称, 标识, 取值范围, 格式, 含义, 及参数间的顺序或依赖等关系.
 * 关键对象: 说明该流程中涉及的关键对象的状态变更和变更条件.
 * 算法: 定义具体计算方法, 和计算步骤. (如果有).
 * 性能: 定义该流程的全部性能要求, 包括输入输出的精度, 灵活性, 时间特性等.

#### 分支流程1 ####

 * 定义分支流程1的输入, 输出, 处理过程等.

#### 页面Demo ####

 * 如果有.

#### 单元测试 ####

 * 描述单元测试的方案, 定义覆盖该USE CASE的单元测试函数. 包括: 测试函数名 称, 测试目标函数, 基本逻辑, 正确结果的描述.
 * 如果需要进行性能测试, 需要说明性能测试的方案, 测试环境, 和需要达到的目标.

## 数据对象定义 ##

 * 定义关键抽象对象及其属性, 定义对象间的依赖, 派生, 聚合等关系. 如果必 要, 可以用类图来表示.
 * 定义关键数据对象的类型, 数据结构, 存储方式.
 * 说明模块的关键对象, 及其状态和在各个流程中的状态改变的条件. 可用状态图 或图表说明(如果有). 如:

关键对象'''trackingOrder'''

|| || new || pending || confirmed || tracking || finished || cancelled ||
|| 流程1 || pending || x || x || x || x || x ||
|| 流程2 || x || confirmed|new || x || x || x || x ||
|| 流程3 || x || x || tracking || x || x || x ||

## 数据库定义 ##

 * n/a

## 接口定义 ##

 * 完善 [wiki: 详细接口设计页面链接]
 * 定义涉及的接口的详细请求方式, 输入, 输出的详细说明. 包括名称, 标识, 取 值范围, 格式, 含义等. 并给出输入输出的 sample.

## 监控设计 ##

 * 描述本模块的监控点和监控规程, 如采用 DBPC 或系统本身实现一个监控模块 (需要说明该监控模块的逻辑和正确输出和异常输出)等. 如:
 * Key Manager: DBPC 心跳监控.
 * Redis Server: 由 Redis Client 定期请求 Redis Server, 发送一个 Get 请 求, 请求 Key 为 &quot;&quot; 的 value. 如果 Redis Server 正常返回或返回无效的 Key 则, Redis Server 正常, 反之, Redis Client 停止 DBPC 的心跳监控.
 * 此外, 可以参考, OPS 监控的要求格式, 提供监控列表. 以有助于 OPS Review. !</rich_text><rich_text link="webs http://color:#3465A4">http://seals.vobile.cn/trac/Ops/wiki/Conventions/Monitor-App</rich_text><rich_text>

## TODO List ##

 * 说明在详细设计阶段, 尚未解决而在系统完成之前必须解决的问题.
 * 说明本详细设计引入的风险, 以及可以实现而没有实现的解决方案.
 * 说明详细设计缺陷, 以及可能的解决方案.
</rich_text></node><node name="gnuplot" prog_lang="sh" readonly="False" tags="" unique_id="54"><rich_text>1. 显示图片
        set term gif
        set output &quot;abc.png&quot;
        plot sin(x)

 2.清单 1. 从 -pi 到 +pi 的 sin(x)
 set xrange [-pi:pi]
 plot sin(x)
 reset
 
 清单 2. 命名图和轴
set title &quot;My first graph&quot;
set xlabel &quot;Angle, \n in degrees&quot;
set ylabel &quot;sin(angle)&quot;
plot sin(x)


带有 tics、标题、网格和标签的轴的 sin(x)
gnuplot&gt; set xrange [-pi:pi]
gnuplot&gt; set xtics (&quot;0&quot; 0, &quot;90&quot; pi/2 , &quot;-90&quot; -pi/2 , &quot;&quot; pi/4 , &quot;&quot; -pi/4 , &quot;&quot; 3*pi/4 , &quot;&quot; -3*pi/4 )
gnuplot&gt; set grid
gnuplot&gt; set xlabel &quot;Angle. \n in degrees&quot;
gnuplot&gt; set ylabel &quot;sin(angle)&quot;
gnuplot&gt; plot sin(x)
gnuplot&gt; set output &quot;test.png&quot;
gnuplot&gt; plot sin(x)
</rich_text></node><node name="todo" prog_lang="custom-colors" readonly="False" tags="" unique_id="22"><rich_text>Linux 剪裁
</rich_text><rich_text link="webs http://blog.csdn.net/jinsen/article/details/4890922">http://blog.csdn.net/jinsen/article/details/4890922</rich_text><rich_text>
2. Linux 破解wifi密码
</rich_text><rich_text link="webs http://linux.cn/thread/12013/1/1/">http://linux.cn/thread/12013/1/1/</rich_text><rich_text>
3. Linux Grep 算法

</rich_text><rich_text link="webs http://www.cnblogs.com/lanxuezaipiao/p/3452579.html">http://www.cnblogs.com/lanxuezaipiao/p/3452579.html</rich_text><rich_text>
4.Linux 技巧
</rich_text><rich_text link="webs http://linux.cn/article-2389-1.html">http://linux.cn/article-2389-1.html</rich_text><rich_text>

python yield generator coroutine &amp;&amp; these in C++
</rich_text></node></cherrytree>